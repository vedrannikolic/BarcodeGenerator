/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/@zxing/library@0.21.0/es2015/core/aztec/encoder/State.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import BitArray from"../../common/BitArray";import*as TokenHelpers from"./TokenHelpers";import*as C from"./EncoderConstants";import*as LatchTable from"./LatchTable";import*as ShiftTable from"./ShiftTable";import StringUtils from"../../common/StringUtils";export default class State{constructor(t,e,i,n){this.token=t,this.mode=e,this.binaryShiftByteCount=i,this.bitCount=n}getMode(){return this.mode}getToken(){return this.token}getBinaryShiftByteCount(){return this.binaryShiftByteCount}getBitCount(){return this.bitCount}latchAndAppend(t,e){let i=this.bitCount,n=this.token;if(t!==this.mode){let e=LatchTable.LATCH_TABLE[this.mode][t];n=TokenHelpers.add(n,65535&e,e>>16),i+=e>>16}let r=t===C.MODE_DIGIT?4:5;return n=TokenHelpers.add(n,e,r),new State(n,t,0,i+r)}shiftAndAppend(t,e){let i=this.token,n=this.mode===C.MODE_DIGIT?4:5;return i=TokenHelpers.add(i,ShiftTable.SHIFT_TABLE[this.mode][t],n),i=TokenHelpers.add(i,e,5),new State(i,this.mode,0,this.bitCount+n+5)}addBinaryShiftChar(t){let e=this.token,i=this.mode,n=this.bitCount;if(this.mode===C.MODE_PUNCT||this.mode===C.MODE_DIGIT){let t=LatchTable.LATCH_TABLE[i][C.MODE_UPPER];e=TokenHelpers.add(e,65535&t,t>>16),n+=t>>16,i=C.MODE_UPPER}let r=0===this.binaryShiftByteCount||31===this.binaryShiftByteCount?18:62===this.binaryShiftByteCount?9:8,o=new State(e,i,this.binaryShiftByteCount+1,n+r);return 2078===o.binaryShiftByteCount&&(o=o.endBinaryShift(t+1)),o}endBinaryShift(t){if(0===this.binaryShiftByteCount)return this;let e=this.token;return e=TokenHelpers.addBinaryShift(e,t-this.binaryShiftByteCount,this.binaryShiftByteCount),new State(e,this.mode,0,this.bitCount)}isBetterThanOrEqualTo(t){let e=this.bitCount+(LatchTable.LATCH_TABLE[this.mode][t.mode]>>16);return this.binaryShiftByteCount<t.binaryShiftByteCount?e+=State.calculateBinaryShiftCost(t)-State.calculateBinaryShiftCost(this):this.binaryShiftByteCount>t.binaryShiftByteCount&&t.binaryShiftByteCount>0&&(e+=10),e<=t.bitCount}toBitArray(t){let e=[];for(let i=this.endBinaryShift(t.length).token;null!==i;i=i.getPrevious())e.unshift(i);let i=new BitArray;for(const n of e)n.appendTo(i,t);return i}toString(){return StringUtils.format("%s bits=%d bytes=%d",C.MODE_NAMES[this.mode],this.bitCount,this.binaryShiftByteCount)}static calculateBinaryShiftCost(t){return t.binaryShiftByteCount>62?21:t.binaryShiftByteCount>31?20:t.binaryShiftByteCount>0?10:0}}State.INITIAL_STATE=new State(C.EMPTY_TOKEN,C.MODE_UPPER,0,0);
//# sourceMappingURL=/sm/d55a89ecc91d64df8ac2166c05e122498169d41acf18010e39de5a532b9df9dd.map