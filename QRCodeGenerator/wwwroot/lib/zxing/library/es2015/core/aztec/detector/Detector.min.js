/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/@zxing/library@0.21.0/es2015/core/aztec/detector/Detector.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import ResultPoint from"../../ResultPoint";import AztecDetectorResult from"../AztecDetectorResult";import MathUtils from"../../common/detector/MathUtils";import WhiteRectangleDetector from"../../common/detector/WhiteRectangleDetector";import GenericGF from"../../common/reedsolomon/GenericGF";import ReedSolomonDecoder from"../../common/reedsolomon/ReedSolomonDecoder";import NotFoundException from"../../NotFoundException";import GridSamplerInstance from"../../common/GridSamplerInstance";import Integer from"../../util/Integer";export class Point{constructor(t,e){this.x=t,this.y=e}toResultPoint(){return new ResultPoint(this.getX(),this.getY())}getX(){return this.x}getY(){return this.y}}export default class Detector{constructor(t){this.EXPECTED_CORNER_BITS=new Int32Array([3808,476,2107,1799]),this.image=t}detect(){return this.detectMirror(!1)}detectMirror(t){let e=this.getMatrixCenter(),i=this.getBullsEyeCorners(e);if(t){let t=i[0];i[0]=i[2],i[2]=t}this.extractParameters(i);let n=this.sampleGrid(this.image,i[this.shift%4],i[(this.shift+1)%4],i[(this.shift+2)%4],i[(this.shift+3)%4]),r=this.getMatrixCornerPoints(i);return new AztecDetectorResult(n,r,this.compact,this.nbDataBlocks,this.nbLayers)}extractParameters(t){if(!(this.isValidPoint(t[0])&&this.isValidPoint(t[1])&&this.isValidPoint(t[2])&&this.isValidPoint(t[3])))throw new NotFoundException;let e=2*this.nbCenterLayers,i=new Int32Array([this.sampleLine(t[0],t[1],e),this.sampleLine(t[1],t[2],e),this.sampleLine(t[2],t[3],e),this.sampleLine(t[3],t[0],e)]);this.shift=this.getRotation(i,e);let n=0;for(let t=0;t<4;t++){let e=i[(this.shift+t)%4];this.compact?(n<<=7,n+=e>>1&127):(n<<=10,n+=(e>>2&992)+(e>>1&31))}let r=this.getCorrectedParameterData(n,this.compact);this.compact?(this.nbLayers=1+(r>>6),this.nbDataBlocks=1+(63&r)):(this.nbLayers=1+(r>>11),this.nbDataBlocks=1+(2047&r))}getRotation(t,e){let i=0;t.forEach(((t,n,r)=>{i=(i<<3)+((t>>e-2<<1)+(1&t))})),i=((1&i)<<11)+(i>>1);for(let t=0;t<4;t++)if(Integer.bitCount(i^this.EXPECTED_CORNER_BITS[t])<=2)return t;throw new NotFoundException}getCorrectedParameterData(t,e){let i,n;e?(i=7,n=2):(i=10,n=4);let r=i-n,s=new Int32Array(i);for(let e=i-1;e>=0;--e)s[e]=15&t,t>>=4;try{new ReedSolomonDecoder(GenericGF.AZTEC_PARAM).decode(s,r)}catch(t){throw new NotFoundException}let o=0;for(let t=0;t<n;t++)o=(o<<4)+s[t];return o}getBullsEyeCorners(t){let e=t,i=t,n=t,r=t,s=!0;for(this.nbCenterLayers=1;this.nbCenterLayers<9;this.nbCenterLayers++){let t=this.getFirstDifferent(e,s,1,-1),o=this.getFirstDifferent(i,s,1,1),g=this.getFirstDifferent(n,s,-1,1),h=this.getFirstDifferent(r,s,-1,-1);if(this.nbCenterLayers>2){let i=this.distancePoint(h,t)*this.nbCenterLayers/(this.distancePoint(r,e)*(this.nbCenterLayers+2));if(i<.75||i>1.25||!this.isWhiteOrBlackRectangle(t,o,g,h))break}e=t,i=o,n=g,r=h,s=!s}if(5!==this.nbCenterLayers&&7!==this.nbCenterLayers)throw new NotFoundException;this.compact=5===this.nbCenterLayers;let o=new ResultPoint(e.getX()+.5,e.getY()-.5),g=new ResultPoint(i.getX()+.5,i.getY()+.5),h=new ResultPoint(n.getX()-.5,n.getY()+.5),a=new ResultPoint(r.getX()-.5,r.getY()-.5);return this.expandSquare([o,g,h,a],2*this.nbCenterLayers-3,2*this.nbCenterLayers)}getMatrixCenter(){let t,e,i,n;try{let r=new WhiteRectangleDetector(this.image).detect();t=r[0],e=r[1],i=r[2],n=r[3]}catch(r){let s=this.image.getWidth()/2,o=this.image.getHeight()/2;t=this.getFirstDifferent(new Point(s+7,o-7),!1,1,-1).toResultPoint(),e=this.getFirstDifferent(new Point(s+7,o+7),!1,1,1).toResultPoint(),i=this.getFirstDifferent(new Point(s-7,o+7),!1,-1,1).toResultPoint(),n=this.getFirstDifferent(new Point(s-7,o-7),!1,-1,-1).toResultPoint()}let r=MathUtils.round((t.getX()+n.getX()+e.getX()+i.getX())/4),s=MathUtils.round((t.getY()+n.getY()+e.getY()+i.getY())/4);try{let o=new WhiteRectangleDetector(this.image,15,r,s).detect();t=o[0],e=o[1],i=o[2],n=o[3]}catch(o){t=this.getFirstDifferent(new Point(r+7,s-7),!1,1,-1).toResultPoint(),e=this.getFirstDifferent(new Point(r+7,s+7),!1,1,1).toResultPoint(),i=this.getFirstDifferent(new Point(r-7,s+7),!1,-1,1).toResultPoint(),n=this.getFirstDifferent(new Point(r-7,s-7),!1,-1,-1).toResultPoint()}return r=MathUtils.round((t.getX()+n.getX()+e.getX()+i.getX())/4),s=MathUtils.round((t.getY()+n.getY()+e.getY()+i.getY())/4),new Point(r,s)}getMatrixCornerPoints(t){return this.expandSquare(t,2*this.nbCenterLayers,this.getDimension())}sampleGrid(t,e,i,n,r){let s=GridSamplerInstance.getInstance(),o=this.getDimension(),g=o/2-this.nbCenterLayers,h=o/2+this.nbCenterLayers;return s.sampleGrid(t,o,o,g,g,h,g,h,h,g,h,e.getX(),e.getY(),i.getX(),i.getY(),n.getX(),n.getY(),r.getX(),r.getY())}sampleLine(t,e,i){let n=0,r=this.distanceResultPoint(t,e),s=r/i,o=t.getX(),g=t.getY(),h=s*(e.getX()-t.getX())/r,a=s*(e.getY()-t.getY())/r;for(let t=0;t<i;t++)this.image.get(MathUtils.round(o+t*h),MathUtils.round(g+t*a))&&(n|=1<<i-t-1);return n}isWhiteOrBlackRectangle(t,e,i,n){t=new Point(t.getX()-3,t.getY()+3),e=new Point(e.getX()-3,e.getY()-3),i=new Point(i.getX()+3,i.getY()-3),n=new Point(n.getX()+3,n.getY()+3);let r=this.getColor(n,t);if(0===r)return!1;let s=this.getColor(t,e);return s===r&&(s=this.getColor(e,i),s===r&&(s=this.getColor(i,n),s===r))}getColor(t,e){let i=this.distancePoint(t,e),n=(e.getX()-t.getX())/i,r=(e.getY()-t.getY())/i,s=0,o=t.getX(),g=t.getY(),h=this.image.get(t.getX(),t.getY()),a=Math.ceil(i);for(let t=0;t<a;t++)o+=n,g+=r,this.image.get(MathUtils.round(o),MathUtils.round(g))!==h&&s++;let l=s/i;return l>.1&&l<.9?0:l<=.1===h?1:-1}getFirstDifferent(t,e,i,n){let r=t.getX()+i,s=t.getY()+n;for(;this.isValid(r,s)&&this.image.get(r,s)===e;)r+=i,s+=n;for(r-=i,s-=n;this.isValid(r,s)&&this.image.get(r,s)===e;)r+=i;for(r-=i;this.isValid(r,s)&&this.image.get(r,s)===e;)s+=n;return s-=n,new Point(r,s)}expandSquare(t,e,i){let n=i/(2*e),r=t[0].getX()-t[2].getX(),s=t[0].getY()-t[2].getY(),o=(t[0].getX()+t[2].getX())/2,g=(t[0].getY()+t[2].getY())/2,h=new ResultPoint(o+n*r,g+n*s),a=new ResultPoint(o-n*r,g-n*s);return r=t[1].getX()-t[3].getX(),s=t[1].getY()-t[3].getY(),o=(t[1].getX()+t[3].getX())/2,g=(t[1].getY()+t[3].getY())/2,[h,new ResultPoint(o+n*r,g+n*s),a,new ResultPoint(o-n*r,g-n*s)]}isValid(t,e){return t>=0&&t<this.image.getWidth()&&e>0&&e<this.image.getHeight()}isValidPoint(t){let e=MathUtils.round(t.getX()),i=MathUtils.round(t.getY());return this.isValid(e,i)}distancePoint(t,e){return MathUtils.distance(t.getX(),t.getY(),e.getX(),e.getY())}distanceResultPoint(t,e){return MathUtils.distance(t.getX(),t.getY(),e.getX(),e.getY())}getDimension(){return this.compact?4*this.nbLayers+11:this.nbLayers<=4?4*this.nbLayers+15:4*this.nbLayers+2*(Integer.truncDivision(this.nbLayers-4,8)+1)+15}}
//# sourceMappingURL=/sm/ec8aadb5e601940971c840c5544d028ceec1380fc607e30d458caccefde5dae5.map