/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/@zxing/library@0.21.0/es2015/core/qrcode/detector/AlignmentPatternFinder.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import AlignmentPattern from"./AlignmentPattern";import NotFoundException from"../../NotFoundException";export default class AlignmentPatternFinder{constructor(t,e,s,n,r,i,o){this.image=t,this.startX=e,this.startY=s,this.width=n,this.height=r,this.moduleSize=i,this.resultPointCallback=o,this.possibleCenters=[],this.crossCheckStateCount=new Int32Array(3)}find(){const t=this.startX,e=this.height,s=t+this.width,n=this.startY+e/2,r=new Int32Array(3),i=this.image;for(let o=0;o<e;o++){const e=n+(0==(1&o)?Math.floor((o+1)/2):-Math.floor((o+1)/2));r[0]=0,r[1]=0,r[2]=0;let l=t;for(;l<s&&!i.get(l,e);)l++;let a=0;for(;l<s;){if(i.get(l,e))if(1===a)r[1]++;else if(2===a){if(this.foundPatternCross(r)){const t=this.handlePossibleCenter(r,e,l);if(null!==t)return t}r[0]=r[2],r[1]=1,r[2]=0,a=1}else r[++a]++;else 1===a&&a++,r[a]++;l++}if(this.foundPatternCross(r)){const t=this.handlePossibleCenter(r,e,s);if(null!==t)return t}}if(0!==this.possibleCenters.length)return this.possibleCenters[0];throw new NotFoundException}static centerFromEnd(t,e){return e-t[2]-t[1]/2}foundPatternCross(t){const e=this.moduleSize,s=e/2;for(let n=0;n<3;n++)if(Math.abs(e-t[n])>=s)return!1;return!0}crossCheckVertical(t,e,s,n){const r=this.image,i=r.getHeight(),o=this.crossCheckStateCount;o[0]=0,o[1]=0,o[2]=0;let l=t;for(;l>=0&&r.get(e,l)&&o[1]<=s;)o[1]++,l--;if(l<0||o[1]>s)return NaN;for(;l>=0&&!r.get(e,l)&&o[0]<=s;)o[0]++,l--;if(o[0]>s)return NaN;for(l=t+1;l<i&&r.get(e,l)&&o[1]<=s;)o[1]++,l++;if(l===i||o[1]>s)return NaN;for(;l<i&&!r.get(e,l)&&o[2]<=s;)o[2]++,l++;if(o[2]>s)return NaN;const a=o[0]+o[1]+o[2];return 5*Math.abs(a-n)>=2*n?NaN:this.foundPatternCross(o)?AlignmentPatternFinder.centerFromEnd(o,l):NaN}handlePossibleCenter(t,e,s){const n=t[0]+t[1]+t[2],r=AlignmentPatternFinder.centerFromEnd(t,s),i=this.crossCheckVertical(e,r,2*t[1],n);if(!isNaN(i)){const e=(t[0]+t[1]+t[2])/3;for(const t of this.possibleCenters)if(t.aboutEquals(e,i,r))return t.combineEstimate(i,r,e);const s=new AlignmentPattern(r,i,e);this.possibleCenters.push(s),null!==this.resultPointCallback&&void 0!==this.resultPointCallback&&this.resultPointCallback.foundPossibleResultPoint(s)}return null}}
//# sourceMappingURL=/sm/c8e582201aeb26908a90102d41651ba3fde70ba45c51af793df38a59542aa774.map