/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/@zxing/library@0.21.0/es2015/core/qrcode/detector/Detector.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import MathUtils from"../../common/detector/MathUtils";import DetectorResult from"../../common/DetectorResult";import GridSamplerInstance from"../../common/GridSamplerInstance";import PerspectiveTransform from"../../common/PerspectiveTransform";import DecodeHintType from"../../DecodeHintType";import NotFoundException from"../../NotFoundException";import ResultPoint from"../../ResultPoint";import Version from"../decoder/Version";import AlignmentPatternFinder from"./AlignmentPatternFinder";import FinderPatternFinder from"./FinderPatternFinder";export default class Detector{constructor(t){this.image=t}getImage(){return this.image}getResultPointCallback(){return this.resultPointCallback}detect(t){this.resultPointCallback=null==t?null:t.get(DecodeHintType.NEED_RESULT_POINT_CALLBACK);const e=new FinderPatternFinder(this.image,this.resultPointCallback).find(t);return this.processFinderPatternInfo(e)}processFinderPatternInfo(t){const e=t.getTopLeft(),i=t.getTopRight(),o=t.getBottomLeft(),n=this.calculateModuleSize(e,i,o);if(n<1)throw new NotFoundException("No pattern found in proccess finder.");const r=Detector.computeDimension(e,i,o,n),a=Version.getProvisionalVersionForDimension(r),s=a.getDimensionForVersion()-7;let l=null;if(a.getAlignmentPatternCenters().length>0){const t=i.getX()-e.getX()+o.getX(),r=i.getY()-e.getY()+o.getY(),a=1-3/s,c=Math.floor(e.getX()+a*(t-e.getX())),g=Math.floor(e.getY()+a*(r-e.getY()));for(let t=4;t<=16;t<<=1)try{l=this.findAlignmentInRegion(n,c,g,t);break}catch(t){if(!(t instanceof NotFoundException))throw t}}const c=Detector.createTransform(e,i,o,l,r),g=Detector.sampleGrid(this.image,c,r);let h;return h=null===l?[o,e,i]:[o,e,i,l],new DetectorResult(g,h)}static createTransform(t,e,i,o,n){const r=n-3.5;let a,s,l,c;return null!==o?(a=o.getX(),s=o.getY(),l=r-3,c=l):(a=e.getX()-t.getX()+i.getX(),s=e.getY()-t.getY()+i.getY(),l=r,c=r),PerspectiveTransform.quadrilateralToQuadrilateral(3.5,3.5,r,3.5,l,c,3.5,r,t.getX(),t.getY(),e.getX(),e.getY(),a,s,i.getX(),i.getY())}static sampleGrid(t,e,i){return GridSamplerInstance.getInstance().sampleGridWithTransform(t,i,i,e)}static computeDimension(t,e,i,o){const n=MathUtils.round(ResultPoint.distance(t,e)/o),r=MathUtils.round(ResultPoint.distance(t,i)/o);let a=Math.floor((n+r)/2)+7;switch(3&a){case 0:a++;break;case 2:a--;break;case 3:throw new NotFoundException("Dimensions could be not found.")}return a}calculateModuleSize(t,e,i){return(this.calculateModuleSizeOneWay(t,e)+this.calculateModuleSizeOneWay(t,i))/2}calculateModuleSizeOneWay(t,e){const i=this.sizeOfBlackWhiteBlackRunBothWays(Math.floor(t.getX()),Math.floor(t.getY()),Math.floor(e.getX()),Math.floor(e.getY())),o=this.sizeOfBlackWhiteBlackRunBothWays(Math.floor(e.getX()),Math.floor(e.getY()),Math.floor(t.getX()),Math.floor(t.getY()));return isNaN(i)?o/7:isNaN(o)?i/7:(i+o)/14}sizeOfBlackWhiteBlackRunBothWays(t,e,i,o){let n=this.sizeOfBlackWhiteBlackRun(t,e,i,o),r=1,a=t-(i-t);a<0?(r=t/(t-a),a=0):a>=this.image.getWidth()&&(r=(this.image.getWidth()-1-t)/(a-t),a=this.image.getWidth()-1);let s=Math.floor(e-(o-e)*r);return r=1,s<0?(r=e/(e-s),s=0):s>=this.image.getHeight()&&(r=(this.image.getHeight()-1-e)/(s-e),s=this.image.getHeight()-1),a=Math.floor(t+(a-t)*r),n+=this.sizeOfBlackWhiteBlackRun(t,e,a,s),n-1}sizeOfBlackWhiteBlackRun(t,e,i,o){const n=Math.abs(o-e)>Math.abs(i-t);if(n){let n=t;t=e,e=n,n=i,i=o,o=n}const r=Math.abs(i-t),a=Math.abs(o-e);let s=-r/2;const l=t<i?1:-1,c=e<o?1:-1;let g=0;const h=i+l;for(let i=t,m=e;i!==h;i+=l){const l=n?m:i,h=n?i:m;if(1===g===this.image.get(l,h)){if(2===g)return MathUtils.distance(i,m,t,e);g++}if(s+=a,s>0){if(m===o)break;m+=c,s-=r}}return 2===g?MathUtils.distance(i+l,o,t,e):NaN}findAlignmentInRegion(t,e,i,o){const n=Math.floor(o*t),r=Math.max(0,e-n),a=Math.min(this.image.getWidth()-1,e+n);if(a-r<3*t)throw new NotFoundException("Alignment top exceeds estimated module size.");const s=Math.max(0,i-n),l=Math.min(this.image.getHeight()-1,i+n);if(l-s<3*t)throw new NotFoundException("Alignment bottom exceeds estimated module size.");return new AlignmentPatternFinder(this.image,r,s,a-r,l-s,t,this.resultPointCallback).find()}}
//# sourceMappingURL=/sm/c939fd9c212ba72331a1c1445fccebe4851e6d35d7e5a6b13e9a5e4674fb3d88.map