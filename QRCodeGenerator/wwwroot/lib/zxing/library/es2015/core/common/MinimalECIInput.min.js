/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/@zxing/library@0.21.0/es2015/core/common/MinimalECIInput.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{ECIEncoderSet}from"./ECIEncoderSet";import Integer from"../util/Integer";import StringBuilder from"../util/StringBuilder";const COST_PER_ECI=3;export class MinimalECIInput{constructor(e,t,r){this.fnc1=r;const n=new ECIEncoderSet(e,t,r);if(1===n.length())for(let t=0;t<this.bytes.length;t++){const n=e.charAt(t).charCodeAt(0);this.bytes[t]=n===r?1e3:n}else this.bytes=this.encodeMinimally(e,n,r)}getFNC1Character(){return this.fnc1}length(){return this.bytes.length}haveNCharacters(e,t){if(e+t-1>=this.bytes.length)return!1;for(let r=0;r<t;r++)if(this.isECI(e+r))return!1;return!0}charAt(e){if(e<0||e>=this.length())throw new Error(""+e);if(this.isECI(e))throw new Error("value at "+e+" is not a character but an ECI");return this.isFNC1(e)?this.fnc1:this.bytes[e]}subSequence(e,t){if(e<0||e>t||t>this.length())throw new Error(""+e);const r=new StringBuilder;for(let n=e;n<t;n++){if(this.isECI(n))throw new Error("value at "+n+" is not a character but an ECI");r.append(this.charAt(n))}return r.toString()}isECI(e){if(e<0||e>=this.length())throw new Error(""+e);return this.bytes[e]>255&&this.bytes[e]<=999}isFNC1(e){if(e<0||e>=this.length())throw new Error(""+e);return 1e3===this.bytes[e]}getECIValue(e){if(e<0||e>=this.length())throw new Error(""+e);if(!this.isECI(e))throw new Error("value at "+e+" is not an ECI but a character");return this.bytes[e]-256}addEdge(e,t,r){(null==e[t][r.encoderIndex]||e[t][r.encoderIndex].cachedTotalSize>r.cachedTotalSize)&&(e[t][r.encoderIndex]=r)}addEdges(e,t,r,n,i,o){const s=e.charAt(n).charCodeAt(0);let h=0,l=t.length();t.getPriorityEncoderIndex()>=0&&(s===o||t.canEncode(s,t.getPriorityEncoderIndex()))&&(h=t.getPriorityEncoderIndex(),l=h+1);for(let e=h;e<l;e++)(s===o||t.canEncode(s,e))&&this.addEdge(r,n+1,new InputEdge(s,t,e,i,o))}encodeMinimally(e,t,r){const n=e.length,i=new(InputEdge[n+1][t.length()]);this.addEdges(e,t,i,0,null,r);for(let o=1;o<=n;o++){for(let s=0;s<t.length();s++)null!=i[o][s]&&o<n&&this.addEdges(e,t,i,o,i[o][s],r);for(let e=0;e<t.length();e++)i[o-1][e]=null}let o=-1,s=Integer.MAX_VALUE;for(let e=0;e<t.length();e++)if(null!=i[n][e]){const t=i[n][e];t.cachedTotalSize<s&&(s=t.cachedTotalSize,o=e)}if(o<0)throw new Error('Failed to encode "'+e+'"');const h=[];let l=i[n][o];for(;null!=l;){if(l.isFNC1())h.unshift(1e3);else{const e=t.encode(l.c,l.encoderIndex);for(let t=e.length-1;t>=0;t--)h.unshift(255&e[t])}(null===l.previous?0:l.previous.encoderIndex)!==l.encoderIndex&&h.unshift(256+t.getECIValue(l.encoderIndex)),l=l.previous}const c=[];for(let e=0;e<c.length;e++)c[e]=h[e];return c}}class InputEdge{constructor(e,t,r,n,i){this.c=e,this.encoderSet=t,this.encoderIndex=r,this.previous=n,this.fnc1=i,this.c=e===i?1e3:e;let o=this.isFNC1()?1:t.encode(e,r).length;(null===n?0:n.encoderIndex)!==r&&(o+=3),null!=n&&(o+=n.cachedTotalSize),this.cachedTotalSize=o}isFNC1(){return 1e3===this.c}}
//# sourceMappingURL=/sm/c064b899f771631e56192cbb83325ce428471938a2a29338a2cac2ff33e97634.map