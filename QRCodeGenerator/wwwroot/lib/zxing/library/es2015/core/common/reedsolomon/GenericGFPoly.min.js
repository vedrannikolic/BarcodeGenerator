/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/@zxing/library@0.21.0/es2015/core/common/reedsolomon/GenericGFPoly.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import AbstractGenericGF from"./AbstractGenericGF";import System from"../../util/System";import IllegalArgumentException from"../../IllegalArgumentException";export default class GenericGFPoly{constructor(e,t){if(0===t.length)throw new IllegalArgumentException;this.field=e;const i=t.length;if(i>1&&0===t[0]){let e=1;for(;e<i&&0===t[e];)e++;e===i?this.coefficients=Int32Array.from([0]):(this.coefficients=new Int32Array(i-e),System.arraycopy(t,e,this.coefficients,0,this.coefficients.length))}else this.coefficients=t}getCoefficients(){return this.coefficients}getDegree(){return this.coefficients.length-1}isZero(){return 0===this.coefficients[0]}getCoefficient(e){return this.coefficients[this.coefficients.length-1-e]}evaluateAt(e){if(0===e)return this.getCoefficient(0);const t=this.coefficients;let i;if(1===e){i=0;for(let e=0,r=t.length;e!==r;e++){const r=t[e];i=AbstractGenericGF.addOrSubtract(i,r)}return i}i=t[0];const r=t.length,n=this.field;for(let l=1;l<r;l++)i=AbstractGenericGF.addOrSubtract(n.multiply(e,i),t[l]);return i}addOrSubtract(e){if(!this.field.equals(e.field))throw new IllegalArgumentException("GenericGFPolys do not have same GenericGF field");if(this.isZero())return e;if(e.isZero())return this;let t=this.coefficients,i=e.coefficients;if(t.length>i.length){const e=t;t=i,i=e}let r=new Int32Array(i.length);const n=i.length-t.length;System.arraycopy(i,0,r,0,n);for(let e=n;e<i.length;e++)r[e]=AbstractGenericGF.addOrSubtract(t[e-n],i[e]);return new GenericGFPoly(this.field,r)}multiply(e){if(!this.field.equals(e.field))throw new IllegalArgumentException("GenericGFPolys do not have same GenericGF field");if(this.isZero()||e.isZero())return this.field.getZero();const t=this.coefficients,i=t.length,r=e.coefficients,n=r.length,l=new Int32Array(i+n-1),o=this.field;for(let e=0;e<i;e++){const i=t[e];for(let t=0;t<n;t++)l[e+t]=AbstractGenericGF.addOrSubtract(l[e+t],o.multiply(i,r[t]))}return new GenericGFPoly(o,l)}multiplyScalar(e){if(0===e)return this.field.getZero();if(1===e)return this;const t=this.coefficients.length,i=this.field,r=new Int32Array(t),n=this.coefficients;for(let l=0;l<t;l++)r[l]=i.multiply(n[l],e);return new GenericGFPoly(i,r)}multiplyByMonomial(e,t){if(e<0)throw new IllegalArgumentException;if(0===t)return this.field.getZero();const i=this.coefficients,r=i.length,n=new Int32Array(r+e),l=this.field;for(let e=0;e<r;e++)n[e]=l.multiply(i[e],t);return new GenericGFPoly(l,n)}divide(e){if(!this.field.equals(e.field))throw new IllegalArgumentException("GenericGFPolys do not have same GenericGF field");if(e.isZero())throw new IllegalArgumentException("Divide by 0");const t=this.field;let i=t.getZero(),r=this;const n=e.getCoefficient(e.getDegree()),l=t.inverse(n);for(;r.getDegree()>=e.getDegree()&&!r.isZero();){const n=r.getDegree()-e.getDegree(),o=t.multiply(r.getCoefficient(r.getDegree()),l),s=e.multiplyByMonomial(n,o),f=t.buildMonomial(n,o);i=i.addOrSubtract(f),r=r.addOrSubtract(s)}return[i,r]}toString(){let e="";for(let t=this.getDegree();t>=0;t--){let i=this.getCoefficient(t);if(0!==i){if(i<0?(e+=" - ",i=-i):e.length>0&&(e+=" + "),0===t||1!==i){const t=this.field.log(i);0===t?e+="1":1===t?e+="a":(e+="a^",e+=t)}0!==t&&(1===t?e+="x":(e+="x^",e+=t))}}return e}}
//# sourceMappingURL=/sm/f1255cc3ecf85483b7b12661e92dad4b88d714eebd6d8891652104f65a426d02.map