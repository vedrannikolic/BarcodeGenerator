/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/@zxing/library@0.21.0/es2015/core/common/reedsolomon/ReedSolomonDecoder.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import GenericGF from"./GenericGF";import GenericGFPoly from"./GenericGFPoly";import ReedSolomonException from"../../ReedSolomonException";import IllegalStateException from"../../IllegalStateException";export default class ReedSolomonDecoder{constructor(e){this.field=e}decode(e,t){const o=this.field,r=new GenericGFPoly(o,e),n=new Int32Array(t);let i=!0;for(let e=0;e<t;e++){const t=r.evaluateAt(o.exp(e+o.getGeneratorBase()));n[n.length-1-e]=t,0!==t&&(i=!1)}if(i)return;const l=new GenericGFPoly(o,n),c=this.runEuclideanAlgorithm(o.buildMonomial(t,1),l,t),a=c[0],g=c[1],s=this.findErrorLocations(a),f=this.findErrorMagnitudes(g,s);for(let t=0;t<s.length;t++){const r=e.length-1-o.log(s[t]);if(r<0)throw new ReedSolomonException("Bad error location");e[r]=GenericGF.addOrSubtract(e[r],f[t])}}runEuclideanAlgorithm(e,t,o){if(e.getDegree()<t.getDegree()){const o=e;e=t,t=o}const r=this.field;let n=e,i=t,l=r.getZero(),c=r.getOne();for(;i.getDegree()>=(o/2|0);){let e=n,t=l;if(n=i,l=c,n.isZero())throw new ReedSolomonException("r_{i-1} was zero");i=e;let o=r.getZero();const a=n.getCoefficient(n.getDegree()),g=r.inverse(a);for(;i.getDegree()>=n.getDegree()&&!i.isZero();){const e=i.getDegree()-n.getDegree(),t=r.multiply(i.getCoefficient(i.getDegree()),g);o=o.addOrSubtract(r.buildMonomial(e,t)),i=i.addOrSubtract(n.multiplyByMonomial(e,t))}if(c=o.multiply(l).addOrSubtract(t),i.getDegree()>=n.getDegree())throw new IllegalStateException("Division algorithm failed to reduce polynomial?")}const a=c.getCoefficient(0);if(0===a)throw new ReedSolomonException("sigmaTilde(0) was zero");const g=r.inverse(a);return[c.multiplyScalar(g),i.multiplyScalar(g)]}findErrorLocations(e){const t=e.getDegree();if(1===t)return Int32Array.from([e.getCoefficient(1)]);const o=new Int32Array(t);let r=0;const n=this.field;for(let i=1;i<n.getSize()&&r<t;i++)0===e.evaluateAt(i)&&(o[r]=n.inverse(i),r++);if(r!==t)throw new ReedSolomonException("Error locator degree does not match number of roots");return o}findErrorMagnitudes(e,t){const o=t.length,r=new Int32Array(o),n=this.field;for(let i=0;i<o;i++){const l=n.inverse(t[i]);let c=1;for(let e=0;e<o;e++)if(i!==e){const o=n.multiply(t[e],l),r=0==(1&o)?1|o:-2&o;c=n.multiply(c,r)}r[i]=n.multiply(e.evaluateAt(l),n.inverse(c)),0!==n.getGeneratorBase()&&(r[i]=n.multiply(r[i],l))}return r}}
//# sourceMappingURL=/sm/0d64985a1e2fdf132c32032b60e79664062f4d6ac6b7a20067145c51cd3af8c7.map