/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/@zxing/library@0.21.0/es2015/core/datamatrix/encoder/HighLevelEncoder.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{ASCIIEncoder}from"./ASCIIEncoder";import{Base256Encoder}from"./Base256Encoder";import{C40Encoder}from"./C40Encoder";import{ASCII_ENCODATION,BASE256_ENCODATION,C40_ENCODATION,EDIFACT_ENCODATION,MACRO_05,MACRO_05_HEADER,MACRO_06,MACRO_06_HEADER,MACRO_TRAILER,PAD,TEXT_ENCODATION,X12_ENCODATION}from"./constants";import{EdifactEncoder}from"./EdifactEncoder";import{EncoderContext}from"./EncoderContext";import{X12Encoder}from"./X12Encoder";import{TextEncoder}from"./TextEncoder";import Arrays from"../../util/Arrays";import Integer from"../../util/Integer";class HighLevelEncoder{static randomize253State(t){const e=PAD+(149*t%253+1);return e<=254?e:e-254}static encodeHighLevel(t,e=0,A=null,C=null,N=!1){const O=new C40Encoder,r=[new ASCIIEncoder,O,new TextEncoder,new X12Encoder,new EdifactEncoder,new Base256Encoder],E=new EncoderContext(t);E.setSymbolShape(e),E.setSizeConstraints(A,C),t.startsWith(MACRO_05_HEADER)&&t.endsWith(MACRO_TRAILER)?(E.writeCodeword(MACRO_05),E.setSkipAtEnd(2),E.pos+=MACRO_05_HEADER.length):t.startsWith(MACRO_06_HEADER)&&t.endsWith(MACRO_TRAILER)&&(E.writeCodeword(MACRO_06),E.setSkipAtEnd(2),E.pos+=MACRO_06_HEADER.length);let i=ASCII_ENCODATION;for(N&&(O.encodeMaximal(E),i=E.getNewEncoding(),E.resetEncoderSignal());E.hasMoreCharacters();)r[i].encode(E),E.getNewEncoding()>=0&&(i=E.getNewEncoding(),E.resetEncoderSignal());const I=E.getCodewordCount();E.updateSymbolInfo();const n=E.getSymbolInfo().getDataCapacity();I<n&&i!==ASCII_ENCODATION&&i!==BASE256_ENCODATION&&i!==EDIFACT_ENCODATION&&E.writeCodeword("Ã¾");const T=E.getCodewords();for(T.length()<n&&T.append(PAD);T.length()<n;)T.append(this.randomize253State(T.length()+1));return E.getCodewords().toString()}static lookAheadTest(t,e,A){const C=this.lookAheadTestIntern(t,e,A);if(A===X12_ENCODATION&&C===X12_ENCODATION){const A=Math.min(e+3,t.length);for(let C=e;C<A;C++)if(!this.isNativeX12(t.charCodeAt(C)))return ASCII_ENCODATION}else if(A===EDIFACT_ENCODATION&&C===EDIFACT_ENCODATION){const A=Math.min(e+4,t.length);for(let C=e;C<A;C++)if(!this.isNativeEDIFACT(t.charCodeAt(C)))return ASCII_ENCODATION}return C}static lookAheadTestIntern(t,e,A){if(e>=t.length)return A;let C;A===ASCII_ENCODATION?C=[0,1,1,1,1,1.25]:(C=[1,2,2,2,2,2.25],C[A]=0);let N=0;const O=new Uint8Array(6),r=[];for(;;){if(e+N===t.length){Arrays.fill(O,0),Arrays.fill(r,0);const t=this.findMinimums(C,r,Integer.MAX_VALUE,O),e=this.getMinimumCount(O);if(r[ASCII_ENCODATION]===t)return ASCII_ENCODATION;if(1===e){if(O[BASE256_ENCODATION]>0)return BASE256_ENCODATION;if(O[EDIFACT_ENCODATION]>0)return EDIFACT_ENCODATION;if(O[TEXT_ENCODATION]>0)return TEXT_ENCODATION;if(O[X12_ENCODATION]>0)return X12_ENCODATION}return C40_ENCODATION}const A=t.charCodeAt(e+N);if(N++,this.isDigit(A)?C[ASCII_ENCODATION]+=.5:this.isExtendedASCII(A)?(C[ASCII_ENCODATION]=Math.ceil(C[ASCII_ENCODATION]),C[ASCII_ENCODATION]+=2):(C[ASCII_ENCODATION]=Math.ceil(C[ASCII_ENCODATION]),C[ASCII_ENCODATION]++),this.isNativeC40(A)?C[C40_ENCODATION]+=2/3:this.isExtendedASCII(A)?C[C40_ENCODATION]+=8/3:C[C40_ENCODATION]+=4/3,this.isNativeText(A)?C[TEXT_ENCODATION]+=2/3:this.isExtendedASCII(A)?C[TEXT_ENCODATION]+=8/3:C[TEXT_ENCODATION]+=4/3,this.isNativeX12(A)?C[X12_ENCODATION]+=2/3:this.isExtendedASCII(A)?C[X12_ENCODATION]+=13/3:C[X12_ENCODATION]+=10/3,this.isNativeEDIFACT(A)?C[EDIFACT_ENCODATION]+=3/4:this.isExtendedASCII(A)?C[EDIFACT_ENCODATION]+=4.25:C[EDIFACT_ENCODATION]+=3.25,this.isSpecialB256(A)?C[BASE256_ENCODATION]+=4:C[BASE256_ENCODATION]++,N>=4){if(Arrays.fill(O,0),Arrays.fill(r,0),this.findMinimums(C,r,Integer.MAX_VALUE,O),r[ASCII_ENCODATION]<this.min(r[BASE256_ENCODATION],r[C40_ENCODATION],r[TEXT_ENCODATION],r[X12_ENCODATION],r[EDIFACT_ENCODATION]))return ASCII_ENCODATION;if(r[BASE256_ENCODATION]<r[ASCII_ENCODATION]||r[BASE256_ENCODATION]+1<this.min(r[C40_ENCODATION],r[TEXT_ENCODATION],r[X12_ENCODATION],r[EDIFACT_ENCODATION]))return BASE256_ENCODATION;if(r[EDIFACT_ENCODATION]+1<this.min(r[BASE256_ENCODATION],r[C40_ENCODATION],r[TEXT_ENCODATION],r[X12_ENCODATION],r[ASCII_ENCODATION]))return EDIFACT_ENCODATION;if(r[TEXT_ENCODATION]+1<this.min(r[BASE256_ENCODATION],r[C40_ENCODATION],r[EDIFACT_ENCODATION],r[X12_ENCODATION],r[ASCII_ENCODATION]))return TEXT_ENCODATION;if(r[X12_ENCODATION]+1<this.min(r[BASE256_ENCODATION],r[C40_ENCODATION],r[EDIFACT_ENCODATION],r[TEXT_ENCODATION],r[ASCII_ENCODATION]))return X12_ENCODATION;if(r[C40_ENCODATION]+1<this.min(r[ASCII_ENCODATION],r[BASE256_ENCODATION],r[EDIFACT_ENCODATION],r[TEXT_ENCODATION])){if(r[C40_ENCODATION]<r[X12_ENCODATION])return C40_ENCODATION;if(r[C40_ENCODATION]===r[X12_ENCODATION]){let A=e+N+1;for(;A<t.length;){const e=t.charCodeAt(A);if(this.isX12TermSep(e))return X12_ENCODATION;if(!this.isNativeX12(e))break;A++}return C40_ENCODATION}}}}}static min(t,e,A,C,N){const O=Math.min(t,Math.min(e,Math.min(A,C)));return void 0===N?O:Math.min(O,N)}static findMinimums(t,e,A,C){for(let N=0;N<6;N++){const O=e[N]=Math.ceil(t[N]);A>O&&(A=O,Arrays.fill(C,0)),A===O&&(C[N]=C[N]+1)}return A}static getMinimumCount(t){let e=0;for(let A=0;A<6;A++)e+=t[A];return e||0}static isDigit(t){return t>="0".charCodeAt(0)&&t<="9".charCodeAt(0)}static isExtendedASCII(t){return t>=128&&t<=255}static isNativeC40(t){return t===" ".charCodeAt(0)||t>="0".charCodeAt(0)&&t<="9".charCodeAt(0)||t>="A".charCodeAt(0)&&t<="Z".charCodeAt(0)}static isNativeText(t){return t===" ".charCodeAt(0)||t>="0".charCodeAt(0)&&t<="9".charCodeAt(0)||t>="a".charCodeAt(0)&&t<="z".charCodeAt(0)}static isNativeX12(t){return this.isX12TermSep(t)||t===" ".charCodeAt(0)||t>="0".charCodeAt(0)&&t<="9".charCodeAt(0)||t>="A".charCodeAt(0)&&t<="Z".charCodeAt(0)}static isX12TermSep(t){return 13===t||t==="*".charCodeAt(0)||t===">".charCodeAt(0)}static isNativeEDIFACT(t){return t>=" ".charCodeAt(0)&&t<="^".charCodeAt(0)}static isSpecialB256(t){return!1}static determineConsecutiveDigitCount(t,e=0){const A=t.length;let C=e;for(;C<A&&this.isDigit(t.charCodeAt(C));)C++;return C-e}static illegalCharacter(t){let e=Integer.toHexString(t.charCodeAt(0));throw e="0000".substring(0,4-e.length)+e,new Error("Illegal character: "+t+" (0x"+e+")")}}export default HighLevelEncoder;
//# sourceMappingURL=/sm/e334226ece4a7eb3ade0236e0665bdeee9dcb055a80220c519a93ad6ebaef30a.map