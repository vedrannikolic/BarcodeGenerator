/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/@zxing/library@0.21.0/es2015/core/datamatrix/DataMatrixWriter.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import BarcodeFormat from"../BarcodeFormat";import BitMatrix from"../common/BitMatrix";import EncodeHintType from"../EncodeHintType";import ByteMatrix from"../qrcode/encoder/ByteMatrix";import Charset from"../util/Charset";import{DefaultPlacement,ErrorCorrection,HighLevelEncoder,MinimalEncoder,SymbolInfo}from"./encoder";export default class DataMatrixWriter{encode(e,t,o,n,r=null){if(""===e.trim())throw new Error("Found empty contents");if(t!==BarcodeFormat.DATA_MATRIX)throw new Error("Can only encode DATA_MATRIX, but got "+t);if(o<0||n<0)throw new Error("Requested dimensions can't be negative: "+o+"x"+n);let i,l=0,a=null,c=null;if(null!=r){const e=r.get(EncodeHintType.DATA_MATRIX_SHAPE);null!=e&&(l=e);const t=r.get(EncodeHintType.MIN_SIZE);null!=t&&(a=t);const o=r.get(EncodeHintType.MAX_SIZE);null!=o&&(c=o)}if(null!=r&&r.has(EncodeHintType.DATA_MATRIX_COMPACT)&&Boolean(r.get(EncodeHintType.DATA_MATRIX_COMPACT).toString())){const t=r.has(EncodeHintType.GS1_FORMAT)&&Boolean(r.get(EncodeHintType.GS1_FORMAT).toString());let o=null;r.has(EncodeHintType.CHARACTER_SET)&&(o=Charset.forName(r.get(EncodeHintType.CHARACTER_SET).toString())),i=MinimalEncoder.encodeHighLevel(e,o,t?29:-1,l)}else{const t=null!=r&&r.has(EncodeHintType.FORCE_C40)&&Boolean(r.get(EncodeHintType.FORCE_C40).toString());i=HighLevelEncoder.encodeHighLevel(e,l,a,c,t)}const m=SymbolInfo.lookup(i.length,l,a,c,!0),d=ErrorCorrection.encodeECC200(i,m),g=new DefaultPlacement(d,m.getSymbolDataWidth(),m.getSymbolDataHeight());return g.place(),this.encodeLowLevel(g,m,o,n)}encodeLowLevel(e,t,o,n){const r=t.getSymbolDataWidth(),i=t.getSymbolDataHeight(),l=new ByteMatrix(t.getSymbolWidth(),t.getSymbolHeight());let a=0;for(let o=0;o<i;o++){let n;if(o%t.matrixHeight==0){n=0;for(let e=0;e<t.getSymbolWidth();e++)l.setBoolean(n,a,e%2==0),n++;a++}n=0;for(let i=0;i<r;i++)i%t.matrixWidth==0&&(l.setBoolean(n,a,!0),n++),l.setBoolean(n,a,e.getBit(i,o)),n++,i%t.matrixWidth==t.matrixWidth-1&&(l.setBoolean(n,a,o%2==0),n++);if(a++,o%t.matrixHeight==t.matrixHeight-1){n=0;for(let e=0;e<t.getSymbolWidth();e++)l.setBoolean(n,a,!0),n++;a++}}return this.convertByteMatrixToBitMatrix(l,o,n)}convertByteMatrixToBitMatrix(e,t,o){const n=e.getWidth(),r=e.getHeight(),i=Math.max(t,n),l=Math.max(o,r),a=Math.min(i/n,l/r);let c,m=(i-n*a)/2,d=(l-r*a)/2;o<r||t<n?(m=0,d=0,c=new BitMatrix(n,r)):c=new BitMatrix(t,o),c.clear();for(let t=0,o=d;t<r;t++,o+=a)for(let r=0,i=m;r<n;r++,i+=a)1===e.get(r,t)&&c.setRegion(i,o,a,a);return c}}
//# sourceMappingURL=/sm/808070846f6ca6bfe284de1dd183a4fbb47b0a67d469ce5d06b5779aecc73c9d.map